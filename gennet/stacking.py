# # -*- coding: utf-8 -*-
# """COVID_2019_STACKING_technique.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1Sz9QnfojeIp9b4BsFzpRW-OlSAbYUp--
# """

# from google.colab import drive
# drive.mount('/content/drive')

# # !cp -R '/content/drive/My Drive/COVID-19/Dataset_3' '/content/'
# !cp -R '/content/drive/My Drive/COVID-19/FuzzyFied_Images2' '/content/'
# # !cp -R '/content/drive/My Drive/COVID-19/Output_Images' '/content/'

# # !cp -R '/content/Output_Images' '/content/drive/My Drive'
# # !rm -Rf '/content/FuzzyFied_Images'

# import os

# print(len(os.listdir('/content/Dataset_3/train/Pneumonia')))

import os
import cv2
import numpy as np
from PIL import Image

def get_stacked_images(original_images, fuzzy_images, batch_size):
    print("----------------------------File chanaged--7")
    #print(fuzzy_images.shape)
    #original_images = np.reshape(original_images, (original_images.shape[0], original_images.shape[1], 3, batch_size), order='F')
    fuzzy_images = np.reshape(fuzzy_images, (fuzzy_images.shape[0], fuzzy_images.shape[1], 3, batch_size), order='F')
    stacked_images = np.empty((original_images.shape[0], original_images.shape[1], 0), order='F')
    #print(original_images.shape, fuzzy_images.shape,stacked_images.shape,batch_size)
    print("Stacking started...")
    for i in range(batch_size):
        background = original_images[:, :, :, i]
        overlay = fuzzy_images[:, :, :, i]

        b_h, b_w, b_ch = background.shape
        o_h, o_w, o_ch = overlay.shape

        try:
            #print("1")
            if 1:
                W = b_w # resimin boyutu
                #oriimg = cv2.imread(filename,cv2.CV_LOAD_IMAGE_COLOR)

                imgScale = W/b_w
                # print('scale:', imgScale)
                new_b_h,new_b_w = int(b_h*imgScale), int(b_w*imgScale)
                new_background = cv2.resize(background,(new_b_w, new_b_h))
                # print(new_background.dtype)
                #cv2.imshow("Show by CV2",new_background)
                #cv2.waitKey(0)
                #cv2.imwrite("resizeimg_new_background.jpg",new_background)

            #print("2")
            if 1:
                W = b_w # resimin boyutu
                #oriimg = cv2.imread(filename,cv2.CV_LOAD_IMAGE_COLOR)

                imgScale = W/o_w
                new_o_h,new_o_w = int(o_h*imgScale), int(o_w*imgScale)
                new_overlay = cv2.resize(overlay,(new_o_w, new_o_h))
                #cv2.imshow("Show by CV2",new_overlay)
                #cv2.waitKey(0)
                #cv2.imwrite("resizeimg_new_overlay.jpg",new_overlay)

            #print("3")
            if 1:
                square= np.zeros((new_b_h, new_b_w, b_ch), np.float64)
                # print(square.shape)
                square.fill(255)
                x= new_b_w
                y= new_b_h
                #print (new_b_h,new_b_w)
                #print (new_o_h,new_o_w)
                offset =0
                broad = {int(y - new_o_h) - offset:int(y)- offset, int(x-new_o_w)- offset:int(x)- offset}
                #print(broad)

                square[int(y - new_o_h) - offset:int(y)- offset, int(x-new_o_w)- offset:int(x)- offset] = new_overlay

            #print("4")
            if 0:
                print("error")
                #cv2.imwrite('C:/Users/IYI/Desktop/datam/yeni_'+str(i)+'.jpg',newimg)

            #print("5")
            if 1: #OVERLAY
                OPACITY = 0.6
                #print("hi")
                new_background = np.asarray(new_background, np.float64)
                square = np.asarray(square, np.float64)
                added_image = cv2.addWeighted(new_background,0.5,square,0.5,0.0)
                #print(added_image.shape)
                #cv2.imshow('adjusted', added_image)  
                #cv2.waitKey()
                #cv2.imwrite(out, added_image)
            #print("6")
            if 1: #CONTRAST

                alpha = 1.5 # Contrast control (1.0-3.0)
                beta = -80 # Brightness control (0-100)

                adjusted = cv2.convertScaleAbs(added_image, alpha=alpha, beta=beta)
                #print("adjusted hsape:",adjusted.shape)
                stacked_images = np.concatenate((stacked_images, adjusted), axis=2)
        except Exception as e:            
            print(e, background.shape, overlay.shape)
    return stacked_images



# original_dir = '/content/Dataset_3'
# fuzzy_dir = '/content/FuzzyFied_Images2'
# output_dir = '/content/Output_Images'

# for split in ['train', 'val']:
#     orig_split_dir = os.path.join(original_dir, split)
#     fuzzy_split_dir = os.path.join(fuzzy_dir, split)
#     output_split_dir = os.path.join(output_dir, split)

#     for cat in os.listdir(orig_split_dir):
#         orig_cat_dir = os.path.join(orig_split_dir, cat)
#         fuzzy_cat_dir = os.path.join(fuzzy_split_dir, cat)
#         output_cat_dir = os.path.join(output_split_dir, cat)

#         for file in os.listdir(orig_cat_dir):
#             bg = os.path.join(orig_cat_dir, file)
#             ov = os.path.join(fuzzy_cat_dir, file)
#             try:
#                 # os.chdir(out) 
#                 # print(bg)
#                 assert os.path.isfile(bg)
#                 assert os.path.isfile(ov)
#                 background = cv2.imread(bg)
#                 b_h, b_w, b_ch = background.shape
#                 #print(b_h, b_w, b_ch)

#                 overlay = cv2.imread(ov)
#                 o_h, o_w, o_ch = overlay.shape
#                 #print(o_h, o_w, o_ch)
#                 if 1:
#                     W = b_w # resimin boyutu
#                     #oriimg = cv2.imread(filename,cv2.CV_LOAD_IMAGE_COLOR)

#                     imgScale = W/b_w
#                     # print('scale:', imgScale)
#                     new_b_h,new_b_w = int(b_h*imgScale), int(b_w*imgScale)
#                     new_background = cv2.resize(background,(new_b_w, new_b_h))
#                     #cv2.imshow("Show by CV2",new_background)
#                     #cv2.waitKey(0)
#                     #cv2.imwrite("resizeimg_new_background.jpg",new_background)


#                 if 1:
#                     W = b_w # resimin boyutu
#                     #oriimg = cv2.imread(filename,cv2.CV_LOAD_IMAGE_COLOR)

#                     imgScale = W/o_w
#                     new_o_h,new_o_w = int(o_h*imgScale), int(o_w*imgScale)
#                     new_overlay = cv2.resize(overlay,(new_o_w, new_o_h))
#                     #cv2.imshow("Show by CV2",new_overlay)
#                     #cv2.waitKey(0)
#                     #cv2.imwrite("resizeimg_new_overlay.jpg",new_overlay)


#                 if 1:
#                     square= np.zeros((new_b_h, new_b_w, b_ch), np.uint8)
#                     square.fill(255)
#                     x= new_b_w
#                     y= new_b_h
#                     #print (new_b_h,new_b_w)
#                     #print (new_o_h,new_o_w)
#                     offset =0
#                     broad = {int(y - new_o_h) - offset:int(y)- offset, int(x-new_o_w)- offset:int(x)- offset}
#                     #print(broad)

#                     square[int(y - new_o_h) - offset:int(y)- offset, int(x-new_o_w)- offset:int(x)- offset] = new_overlay


#                 if 0:
#                     print("error")
#                     #cv2.imwrite('C:/Users/IYI/Desktop/datam/yeni_'+str(i)+'.jpg',newimg)


#                 if 1: #OVERLAY
#                     OPACITY = 0.6
#                     added_image = cv2.addWeighted(new_background,0.5,square,0.5,0)
#                     #cv2.imshow('adjusted', added_image)  
#                     #cv2.waitKey()
#                     #cv2.imwrite(out, added_image)
#                 if 1: #CONTRAST

#                     alpha = 1.5 # Contrast control (1.0-3.0)
#                     beta = -80 # Brightness control (0-100)

#                     adjusted = cv2.convertScaleAbs(added_image, alpha=alpha, beta=beta)


#                     #cv2.imshow('adjusted', adjusted)
#                     # cv2.waitKey()
#                     tgcr=os.path.join(output_cat_dir, file) # burada dosyanın ismini belirleyerek farklı kaydedilmesini sağlıyoruz..
#                     cv2.imwrite(tgcr, adjusted) # resim out değikenin de belirtilen adrese tgcr uzantılı olarak kayıt ediliyor..
#             except:
#                 print(bg, ov)
#                 # cv2.waitKey()

